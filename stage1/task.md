# Этап 1: Теоретические вопросы (15-20 минут)

Ответил, не так развернуто т.к. гуглить\спрашивать нейронки - нечестно, в первую очередь прохожу для себя тест, чтобы понимать все свои стороны. Где не знаю чего-то, использовал догадки.

## 1. Frontend:

1.  **Объясните разницу между виртуальным DOM и реальным DOM и почему React использует виртуальный DOM.**
    Возможно, это связано со скоростью "создания\обновления" страницы. Нужно чтобы и html отобразился (срендерился), так еще и скрипты выполнились. Скорее всего, в виртуальном DOM это происходит быстрее.

2.  **В чем различие между `==` и `===` в JavaScript? Приведите примеры, когда каждый из них будет давать неожиданные результаты.**
    Возможно, это про типы данных. Видел посты в тематических группах про фронтенд, когда `"1" === 1` false и `"1" == 1` true, но больше не вспомню.

3.  **Опишите, что такое “контекст” в JavaScript и как он может изменяться. Приведите примеры использования bind, call и apply.**
    Не знаю.

4.  **Объясните, как работают promises и async/await, и приведите пример кода с обработкой ошибок.**
    Скорее всего, promises связан с асинхронным выполнением функций без блокировки потока, а async\await - синтаксис, который используется для определения и вызова таких функций.

## 2. Backend:

1.  **Как вы обеспечиваете безопасность API от SQL-инъекций?**
    Не использовать f-string, т.е. использовать параметризированные запросы или ORM.

2.  **Какие еще типы атак нужно учитывать?**
    Не показывать traceback ошибки в ответе, т.к. это может дать почву для атаки.
    Проверять права доступа к объектам, не доверять id, отправляемым с клиента.
    Нужно экранировать html, т.к., например, в переменной может быть скрипт, выполняющийся в браузере.
    Не допускать безлимитных запросов, обязательно должен быть rate limitter.

3.  **Объясните, что такое RESTful API и какие существуют методы HTTP-запросов. Как они соответствуют CRUD-операциям?**
    Это архитектурный стиль кода, который позволяет обмениваться данными между серверами.
    Методы существуют следующие: GET, POST, PUT, PATCH, DELETE.
    Соответствие с CRUD:
    *   GET = Read
    *   POST = Create
    *   PUT = Update полностью
    *   PATCH = Update частично
    *   DELETE = Delete

4.  **Чем отличаются реляционные и нереляционные базы данных? В каких случаях лучше использовать каждую из них?**
    **Реляционные (SQL):**
    *   Есть четкая схема хранения данных, подходит для банкинга, бухгалтерии.
    *   Хранение данных в таблицах.
    *   Для работы со связями используется JOIN.
    *   Масштабируется вертикально.

    **Нереляционные (NoSQL):**
    *   Уместно применять в проектах, где нет четкой схемы хранения данных, а также ее отсутствие. Подходит для логов, чатов, сессий.
    *   Хранение данных ключ-значение (или другие гибкие структуры).
    *   Работа со связями выполняется вне логики БД.
    *   Масштабируется горизонтально.

5.  **Как бы вы организовали логирование и мониторинг для серверного приложения?**
    Логирование с помощью отправки их в elasticsearch + визуализация по запросу.
    Мониторинг через jaeger + prometheus.

## 3. Базы данных:

1.  **Объясните разницу между индексацией и нормализацией данных. Приведите пример, когда избыточность данных может быть полезной.**
    *   **Индексация** - когда ты знаешь по каким столбцам искать, ты делаешь из них оглавление как в книге, ускоряет `SELECT` + операторы.
    *   **Нормализация** - приводит данные к "заданному" виду, улучшает целостность данных, убирает дублирование. Применяется при частых операциях записи. Замедляет `SELECT`, т.к. требуется использовать чаще JOIN.
    Пример уместной избыточности. База онлайн кинотеатра. Есть такой объект как фильм, у него есть актеры, рецензии, комментарии и прочее. При классическом представлении хранении данных (нормализованном), отчет показывающий кол-во чего либо в фильмах, будет делаться дольше за счет JOINов, чем при избыточном варианте.

2.  **В чем различие между JOIN и UNION в SQL? Когда использовать каждый из них?**
    *   **JOIN** нужен для получения данных из нескольких связанных таблиц - например, получить имя автора и написанную им книгу.
    *   **UNION** нужен для объединения данных из нескольких несвязанных запросов (или таблиц с одинаковой структурой результата), удаляя дубликаты. Получить имена сотрудников разных должностей (каждая должность своя таблица).

35 МИНУТ
